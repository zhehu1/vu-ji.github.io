{"version":3,"sources":["pages/react/react-redux/index.md","pages/react/react-redux/index.tsx"],"names":["module","exports","ReactRedux","mdDoc"],"mappings":"2GAAAA,EAAOC,QAAU,uuI,iCCAjB,kDAQeC,UAJQ,WACnB,OAAO,cAAC,IAAD,UAAeC","file":"static/js/3.ed3ea724.chunk.js","sourcesContent":["module.exports = \"## Redux\\n\\n### 为什么要用Redux  \\n  \\n1. react 中数据单向流动，非父子组件通信相对麻烦，redux就是为了解决跨组件state数据问题  \\n2. UI 层级比较复杂，有较多交互场景时\\n\\n**应用场景**  \\n1. 用户操作较为繁琐，导致组件间依赖关系复杂。如，通过多筛选组件控制其它组件功能  \\n2. 权限较多且有不同的使用方式，如管管理层、普通层等  \\n3. 数据交互较多，请求实时性要求较高需要保持鲜活度  \\n4. 缓存数据较多，记录用户对表单的提交前操作、分页控制等  \\n\\n### 数据流向\\n![](!./../img/img1.jpeg)  \\n\\ndispatch(action) -> reducer -> subscribe -> view   \\n\\n### redux 应用的三大原则\\n1. 单一数据原则 - 全局store下进行统一配置\\n2. state只读 - 必须通过 action 来改变state，触发更新，直接修改state无效\\n3. reducer 必须是纯函数 - 通过 state 和 action 计算出新 state \\n\\n\\n### applyMiddleware 实现\\n\\n```js\\nexport default function applyMiddleware (...middlewares) {\\n    return (next) => (reducer, initialState) => {\\n        var store = next(reducer, initialState);\\n        var dispatch = store.dispatch;\\n        var chain =[];\\n        var middlewareAPI = {\\n            getState: store.getState, \\n            dispatch:(action)=>dispatch(action)\\n        };\\n        chain = middlewares.map(middleware =>middleware(middlewareAPI)); \\n        dispatch = compose(...chain, store.dispatch);\\n        return {\\n            ...store,\\n            dispatch\\n        };\\n    };\\n}\\n```\\n\\n\\n#### redux-thunk  \\nredux中间件-主要处理异步问题  \\n\\n优点： 库小，代码就几行  \\n缺点：代码臃肿，reducer不再是纯粹函数，直接返回对象，违背了当初的设计原则  \\n\\n```js\\nfunction createThunkMiddleware(extraArgument) {\\n  return ({ dispatch, getState }) => (next) => (action) => {\\n    if (typeof action === 'function') {\\n      return action(dispatch, getState, extraArgument);\\n    }\\n\\n    return next(action);\\n  };\\n}\\n\\nconst thunk = createThunkMiddleware();\\nthunk.withExtraArgument = createThunkMiddleware;\\n\\nexport default thunk;\\n```\\n\\n#### redux-saga\\n异步操作——>Effect函数——>纯文本对象——>saga-middleware——>执行异步操作  \\n优点：\\n  -  将异步与reducer区分开了，更加优雅，适合大量APi请求，而且每个请求之间存在复杂\\n  -  集中处理了所有的异步操作，异步接口部分一目了然  \\n  -  action是普通对象，这跟redux同步的action一模一样  \\n  -  通过Effect，方便异步接口的测试  \\n  -  通过worker 和 watcher 可以实现非阻塞异步调用，并且同时可以实现非阻塞调用下的事件监听  \\n  -  异步操作的流程是可以控制的，可以随时取消相应的异步操作。    \\n  \\n缺点：复杂度高，学习成本较高\";","import React, { FC } from 'react'\nimport AntdMarkdown from '@/components/antdMarkdown'\nimport mdDoc from './index.md'\n\nconst ReactRedux: FC = () => {\n    return <AntdMarkdown>{mdDoc}</AntdMarkdown>\n}\n\nexport default ReactRedux"],"sourceRoot":""}